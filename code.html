<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Triple Phase LUT Calculator</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body{background:#000;color:#fff;font-family:Arial;margin:0;}
header{text-align:center;padding:25px;background:linear-gradient(90deg,#111,#000);}
.container{max-width:1000px;margin:auto;padding:20px;}
.card{background:#111;border-radius:15px;padding:20px;margin-bottom:20px;}
input,textarea{
width:100%;padding:8px;margin-top:5px;background:#000;
border:1px solid #333;color:#fff;border-radius:6px;
}
button{
margin-top:15px;padding:12px;width:100%;
border:none;background:#fff;color:#000;
font-weight:bold;border-radius:8px;cursor:pointer;
}
textarea{height:180px;font-family:monospace;}
</style>
</head>

<body>

<div class="container">

<div class="card">

<label>Input Range</label>
<input id="input_range" value="257">

<label>Phase 1 Velocity</label>
<input id="phase1_velocity" value="6.6">

<label>Phase 2 Velocity</label>
<input id="phase2_velocity" value="23">

<label>Phase 3 Velocity</label>
<input id="phase3_velocity" value="53">

<label>Phase 1 Cap</label>
<input id="phase1_cap" value="60">

<label>Phase 2 Start</label>
<input id="phase2_start" value="152">

<label>Phase 3 Start</label>
<input id="phase3_start" value="180">

<label>Smooth Factor</label>
<input id="smooth_factor" value="0.1">

<button onclick="generateCurve()">Generate LUT</button>
<button onclick="copyLUT()">Copy LUT</button>

<textarea id="lutOutput"></textarea>

</div>

<div class="card">
<canvas id="chart"></canvas>
</div>

</div>

<script>

let chart;
const MAX_POINTS = 257;

/* ---------- SAFE NUMBER ---------- */
function safe(v,def){
v=Number(v);
return isFinite(v)?v:def;
}

/* ---------- AUTO ADJUST ENGINE ---------- */
function autoAdjust(cfg){

/* ranges */
cfg.input_range = Math.min(257, Math.max(32, cfg.input_range));

/* velocities must increase */
if(cfg.p2v <= cfg.p1v)
cfg.p2v = cfg.p1v + 0.01;

if(cfg.p3v <= cfg.p2v)
cfg.p3v = cfg.p2v + 0.01;

/* phase ordering */
cfg.p1cap = Math.max(2, cfg.p1cap);
cfg.p2start = Math.max(cfg.p1cap+1, cfg.p2start);
cfg.p3start = Math.max(cfg.p2start+1, cfg.p3start);

/* keep inside range */
cfg.p3start = Math.min(cfg.input_range-1, cfg.p3start);

/* smoothing safe */
cfg.smooth = Math.min(2, Math.max(0.0001, cfg.smooth));

return cfg;
}

/* ---------- SIGMOID ---------- */
function sigmoid(x){
return 1/(1+Math.exp(-x));
}

/* ---------- RAW ACCEL SAFE FIX ---------- */
function fixLUT(data){

let out=[];
let lastX=0.001;

out.push({x:lastX,y:1});

for(let p of data){

if(!p||!isFinite(p.x)||!isFinite(p.y)) continue;

let x=Math.max(lastX+0.001,p.x);
let y=Math.max(0,Math.min(5,p.y));

out.push({x,y});
lastX=x;
}

/* trim to 257 */
if(out.length>MAX_POINTS){
let step=(out.length-1)/(MAX_POINTS-1);
let trimmed=[];
for(let i=0;i<MAX_POINTS;i++){
trimmed.push(out[Math.round(i*step)]);
}
out=trimmed;
}

return out;
}

/* ---------- GENERATE ---------- */
function generateCurve(){

try{

let cfg={
input_range:safe(input_range.value,257),
p1v:safe(phase1_velocity.value,1),
p2v:safe(phase2_velocity.value,2),
p3v:safe(phase3_velocity.value,3),
p1cap:safe(phase1_cap.value,60),
p2start:safe(phase2_start.value,120),
p3start:safe(phase3_start.value,180),
smooth:safe(smooth_factor.value,0.1)
};

/* AUTO FIX EVERYTHING */
cfg=autoAdjust(cfg);

let raw=[];
let xs=[];
let ys=[];

for(let x=1;x<=cfg.input_range;x++){

let y;

if(x<=cfg.p1cap){
y=(cfg.p1v/cfg.p1cap)*x;
}
else if(x<cfg.p2start){
let mid=(cfg.p1cap+cfg.p2start)/2;
y=cfg.p1v+(cfg.p2v-cfg.p1v)*sigmoid(cfg.smooth*(x-mid));
}
else if(x<cfg.p3start){
let mid=(cfg.p2start+cfg.p3start)/2;
y=cfg.p2v+(cfg.p3v-cfg.p2v)*sigmoid(cfg.smooth*(x-mid));
}
else{
y=cfg.p3v;
}

raw.push({x,y});
xs.push(x);
ys.push(y);
}

const safeLUT=fixLUT(raw);

lutOutput.value=safeLUT
.map(p=>`${p.x.toFixed(3)},${p.y.toFixed(3)};`)
.join("\n");

drawChart(xs,ys);

}catch(e){
console.log("Auto recovered from error:",e);
}
}

/* ---------- GRAPH ---------- */
function drawChart(x,y){

if(chart) chart.destroy();

chart=new Chart(document.getElementById("chart"),{
type:"line",
data:{
labels:x,
datasets:[{
data:y,
borderColor:"white",
borderWidth:2,
pointRadius:0
}]
},
options:{
plugins:{legend:{display:false}},
scales:{
x:{ticks:{color:"white"},grid:{color:"#222"}},
y:{ticks:{color:"white"},grid:{color:"#222"}}
}
}
});
}

/* ---------- COPY ---------- */
function copyLUT(){
if(!lutOutput.value) return;
lutOutput.select();
document.execCommand("copy");
}

</script>
</body>
</html>
